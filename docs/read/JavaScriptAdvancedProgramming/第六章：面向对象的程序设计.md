---
sidebar: true
prev: /read/JavaScriptAdvancedProgramming/第四章：变量、作用域和内存问题
next: false
---

# 第六章：面向对象的程序设计

## 理解对象

1. 属性类型

    1. 数据属性

        * Configurable: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认为true

        * Enumerable: 表示能否通过for-in循环返回属性。默认为true

        * Writable: 表示能否修改属性的值。默认为true

        * Value: 包含这个属性的数据值。默认值为undefined

        * 要修改属性默认的特性，必须使用Object.defineProperty()方法。

    2. 访问器属性

        * Configurable

        * Enumberable

        * Get: 在读取属性时调用的函数。默认值为undefined

        * Set: 在写入属性时调用的函数。默认值为undefined

        * 访问器属性不能直接定义，必须使用Object.defineProperty()来定义

2. 定义多个属性

    * 通过Ojbect.defineProperties()来定义

3. 读取属性的特性

    * 使用Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数： 属性所在的对象和要读取其描述符的属性名称。

## 创建对象

1. 工厂模式

> 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。

```javascript
function createPerson (name, age, job) {
  var o = new Object()
  o.name = name
  o.age = age
  o.job = job
  o.sayName = function () {
    console.log(this.name)
  }
  return o
}
var person1 = createPerson('Ni', 29, 'Software Engineer')
var person2 = createPerson('Greg', 27, 'Doctor')
```

2. 构造函数模式

> 利用构造函数来创建对象

```javascript
function Person (name, age, job) {
  this.name = name
  this.age = age
  this.job = job
  this.sayName = function () {
    console.log(this.name)
  }
}
var person1 = new Person('Ni', 29, 'Software Engineer')
var person2 = new Person('Greg', 27, 'Doctor')
console.log(person1.sayName === person2.sayName) // false  每次创建实例都会创建新的实例方法，相当于执行了new Function()
```

在这个例子中，Person函数取代了createPerson函数.两个函数的不同之处：

* 没有显式地创建对象

* 直接将属性和方法赋给了this对象

* 没有return语句

要创建Person的新实例，必须使用new操作符.以这种方式调用构造函数实际上会经历以下4个步骤：

1. 创建一个新对象

2. 将构造函数的作用域赋给新对象

3. 执行构造函数中的代码

4. 返回新对象

构造函数的问题

* 每个方法都要在每个实例上重新创建一遍。没有达到复用的效果

3. 原型模式

* 我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型的好处就是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。

```javascript
function Person () {
}
Person.prototype.name = 'Ni'
Person.prototype.age = 29
Person.prototype.job = 'Soft'
Person.prototype.sayName = function () {
  console.log(this.name)
}
var person1 = new Person()
person1.sayName() // 'Ni'
var person2 = new Person()
person2.sayName() // 'Ni'
console.log(person1.sayName === person2.sayName) // true  实现了方法复用
```

* 理解原型对象

  - 无论什么时候， 只要创建了一个新函数， 就会根据一级特定的规则为该函数创建一个prototyp属性， 这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）的属性，这个属性包含一个指向prototype属性所在函数的指针。、

  - 创建了自定义的构造函数之后， 其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的.

  - 当调用构造函数创建一个实例之后，该实例的内部将包含一个指针（内部属性）， 指向构造函数的原型对象。ECMA-262管这个指针叫[[[[prototype]]]]。虽然在脚本中没有标准的方式访问[[prototype]]，但在safari、firefox、chorme在每个对象上都支持一个属性__proto__。

  - isPrototypeOf() 方法来确定对象是否是另一个对象的原型对象

  ```javascript
  Person.prototype.isPrototypeOf(person1)
  ```
  - Object.getPrototypeOf()方法可以返回对象[[prototype]]的值
  ```javascript
  Object.getPrototypeOf(person1)  === person1.__proto__
  ```
  - hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。

  - 原型与in操作符

      - 有两种方法使用in操作符: 单独使用和在for-in循环中使用。单独作用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。